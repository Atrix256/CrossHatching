* maybe seperate render target into it's own class. (with set RT, clear, etc)
* draw to render target, and have it then render from rt to screen
* maybe make the main render target use the render target class too


get a compute shader running that writes to a texture
 * texture seems like it should be: D3D11_USAGE_DEFAULT.  Readable / writable by GPU!

may not need render target class, we may only need the single render target, and just have compute shaders read/write to default usage textures?

use a structured buffer for triangles? (models being ray traced)

i think i'll need a deferred renderer type setup? I'll have an intermediary buffer that has uv and intensity that i will then process with the shader.

i don't think we need a depth buffer since it'll all be path traced, so remove that (eventually)

do i need to do anything to strip unused shader constants or otherwise only fill in those used etc?

a way to specify a scene? list spheres and meshes. they get loaded and passed through to the scene.

allow a way to specify screen w/h and fullscreen. Command line?

show fps / mspf

test x64 and release

TODO's

Figure out how to get labels that show up in renderdoc

Sean said he'd be willing to give me textures.

Work with sean for the franklin booth technioque?

* put shaders in a shader folder
* put art in an art folder

================================= HIGH LEVEL GOALS =================================

1) path trace diffuse / emissive of a scene with a mesh. (monochromatic?)
2) use the brightness values to determine which tileable crosshatching texture to use (trilinear filtering w/ volume texture)
3) success!
4) maybe multiple scenes and some debug displays and such. (IMGUI? Or rely on renderdoc?)

================================= NOTES =================================

DX11 guid: http://www.rastertek.com/dx11tut02.html

