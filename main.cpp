#define _CRT_SECURE_NO_WARNINGS

#include <chrono>
#include <random>
#include "d3d11.h"
#include "Shader.h"
#include "Model.h"
#include "Texture.h"
#include "Window.h"
#include "ShaderTypes.h"
#include "ConstantBuffer.h"
#include "StructuredBuffer.h"
#include "Scenes.h"
#include "imgui/imgui.h"

// globals
CD3D11 g_d3d;

bool g_showGrey = false;
bool g_showCrossHatch = false;
bool g_smoothStep = false;
bool g_aniso = false;
bool g_whiteAlbedo = false;

CModel<ShaderTypes::VertexFormats::Pos2D> g_fullScreenMesh;
CModel<ShaderTypes::VertexFormats::IMGUI> g_IMGUIMesh;

CTexture g_IMGUIFont;

// for imgui (but could also be for FPS calculation and such)
static INT64                    g_Time = 0;
static INT64                    g_TicksPerSecond = 0;

float RandomFloat (float min, float max)
{
    static std::random_device rd;
    static std::mt19937 mt(rd());
    std::uniform_real_distribution<float> dist(min, max);
    return dist(mt);
}

// automatically reflected things for shaders
namespace ShaderData
{
    namespace ConstantBuffers
    {
        #define CONSTANT_BUFFER_BEGIN(NAME) CConstantBuffer<ShaderTypes::ConstantBuffers::##NAME> NAME;
        #include "ShaderTypesList.h"
    };

    namespace StructuredBuffers
    {
        #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) CStructuredBuffer<ShaderTypes::StructuredBuffers::##TYPENAME, COUNT> NAME;
        #include "ShaderTypesList.h"
    };

    namespace Textures
    {
        #define TEXTURE_IMAGE(NAME, FILENAME) CTexture NAME;
        #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) CTexture NAME;
        #define TEXTURE_VOLUME_BEGIN(NAME) CTexture NAME;
        #define TEXTURE_ARRAY_BEGIN(NAME) CTexture NAME;
        #include "ShaderTypesList.h"
    }

    namespace Shaders
    {
        #define SHADER_CS_BEGIN(NAME, FILENAME, ENTRY) std::array<CComputeShader, (uint64_t)1 << (uint64_t)EStaticBranches_CS_##NAME::COUNT> NAME;
        #define SHADER_VSPS_BEGIN(NAME, FILENAME, VSENTRY, PSENTRY, VERTEXFORMAT) std::array<CShader, (uint64_t)1 << (uint64_t)EStaticBranches_VSPS_##NAME::COUNT> NAME;
        #include "ShaderTypesList.h"
    };

    namespace VertexFormats
    {
        #define VERTEX_FORMAT_BEGIN(NAME) D3D11_INPUT_ELEMENT_DESC NAME [] = {
        #define VERTEX_FORMAT_FIELD(NAME, SEMANTIC, INDEX, CPPTYPE, SHADERTYPE, FORMAT) \
            {#SEMANTIC, INDEX, FORMAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0},
        #define VERTEX_FORMAT_END };
        #include "ShaderTypesList.h"

        #define VERTEX_FORMAT_BEGIN(NAME) size_t NAME##Elements = sizeof(NAME) / sizeof(NAME[0]);
        #include "ShaderTypesList.h"
    }

    // TODO: move this shader stuff to another file? like shadertypes.cpp

    // make shader permutation selection functions
    #define SHADER_CS_BEGIN(NAME, FILENAME, ENTRY) \
        const CComputeShader& GetShader_##NAME (const std::array<bool, (size_t)ShaderData::Shaders::EStaticBranches_CS_##NAME::COUNT>& params) \
        { \
            auto& permutations = ShaderData::Shaders::NAME; \
            size_t permutationIndex = 0; \
            size_t branchIndex = 0;
    #define SHADER_CS_STATICBRANCH(NAME) if (params[branchIndex]) { permutationIndex |= ((size_t)1 << branchIndex); } ++branchIndex;
    #define SHADER_CS_END return permutations[permutationIndex]; }
    #define SHADER_VSPS_BEGIN(NAME, FILENAME, VSENTRY, PSENTRY, VERTEXFORMAT) \
        const CShader& GetShader_##NAME (const std::array<bool, (size_t)ShaderData::Shaders::EStaticBranches_VSPS_##NAME::COUNT>& params) \
        { \
            auto& permutations = ShaderData::Shaders::NAME; \
            size_t permutationIndex = 0; \
            size_t branchIndex = 0;
    #define SHADER_VSPS_STATICBRANCH(NAME) if (params[branchIndex]) { permutationIndex |= ((size_t)1 << branchIndex); } ++branchIndex;
    #define SHADER_VSPS_END return permutations[permutationIndex]; }
    #include "ShaderTypesList.h"

    // make shader static branch creation functions
    #define SHADER_CS_BEGIN(NAME, FILENAME, ENTRY) \
        bool WriteStaticBranches_CS_##NAME (uint64_t permutation) \
        { \
            FILE *file = fopen("Shaders/StaticBranches.h", "w+t"); \
            if (!file) \
                return false; \
            fprintf(file, "//This file is autogenerated for each shader, using ShaderTypesList.h as source data\n\n"); \
            uint64_t mask = 1;            
    #define SHADER_CS_STATICBRANCH(NAME) \
            fprintf(file, "#define " #NAME " %i\n", (permutation & mask) ? 1 : 0); \
            mask *= 2;
    #define SHADER_CS_END \
            fclose(file); \
            return true; \
        }
    #define SHADER_VSPS_BEGIN(NAME, FILENAME, VSENTRY, PSENTRY, VERTEXFORMAT) \
        bool WriteStaticBranches_VSPS_##NAME (uint64_t permutation) \
        { \
            FILE *file = fopen("Shaders/StaticBranches.h", "w+t"); \
            if (!file) \
                return false; \
            fprintf(file, "//This file is autogenerated for each shader, using ShaderTypesList.h as source data\n\n"); \
            uint64_t mask = 1;            
    #define SHADER_VSPS_STATICBRANCH(NAME) \
            fprintf(file, "#define " #NAME " %i\n", (permutation & mask) ? 1 : 0); \
            mask *= 2;
    #define SHADER_VSPS_END \
            fclose(file); \
            return true; \
        }
    #include "ShaderTypesList.h"
};

// generate shader code ShaderTypes.h
bool WriteShaderTypesHLSL (void)
{
    FILE *file = fopen("Shaders/ShaderTypes.h", "w+t");
    if (!file)
        return false;

    fprintf(file, "//This file is autogenerated by WriteShaderTypesHLSL(), using ShaderTypesList.h as source data\n\n");

    // static branches
    fprintf(file, "#include \"StaticBranches.h\"\n\n");

    // hard coded sampler states
    fprintf(file, "//----------------------------------------------------------------------------\n//Samplers\n//----------------------------------------------------------------------------\n");
    fprintf(file, "SamplerState SamplerLinearWrap;\nSamplerState SamplerNearestWrap;\nSamplerState SamplerAnisoWrap;\n\n");

    // write the texture declarations
    fprintf(file, "//----------------------------------------------------------------------------\n//Textures\n//----------------------------------------------------------------------------\n");
    #define TEXTURE_IMAGE(NAME, FILENAME) fprintf(file, "Texture2D " #NAME ";\nRWTexture2D<float4> " #NAME "_rw;\n\n");
    #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) fprintf(file, "Texture2D " #NAME ";\nRWTexture2D<" #SHADERTYPE "> " #NAME "_rw;\n\n");
    #define TEXTURE_VOLUME_BEGIN(NAME) fprintf(file, "Texture3D " #NAME ";\n\n");
    #define TEXTURE_ARRAY_BEGIN(NAME) fprintf(file, "Texture2DArray " #NAME ";\n\n");
    #include "ShaderTypesList.h"

    // write the cbuffer declarations
    fprintf(file, "//----------------------------------------------------------------------------\n//Constant Buffers\n//----------------------------------------------------------------------------\n");
    #define CONSTANT_BUFFER_BEGIN(NAME) fprintf(file, "cbuffer " #NAME "\n{\n");
    #define CONSTANT_BUFFER_FIELD(NAME, TYPE) fprintf(file,"  " #TYPE " " #NAME ";\n");
    #define CONSTANT_BUFFER_END fprintf(file, "};\n\n");
    #include "ShaderTypesList.h"

    // write the vertex formats
    fprintf(file, "//----------------------------------------------------------------------------\n//Vertex Formats\n//----------------------------------------------------------------------------\n");
    #define VERTEX_FORMAT_BEGIN(NAME) fprintf(file, "struct " #NAME "\n{\n");
    #define VERTEX_FORMAT_FIELD(NAME, SEMANTIC, INDEX, CPPTYPE, SHADERTYPE, FORMAT) fprintf(file, "  " #SHADERTYPE " " #NAME " : " #SEMANTIC #INDEX ";\n");
    #define VERTEX_FORMAT_END fprintf(file, "};\n\n");
    #include "ShaderTypesList.h"

    // write the struct declarations for structured buffers
    fprintf(file, "//----------------------------------------------------------------------------\n//Structured Buffer Types\n//----------------------------------------------------------------------------\n");
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) fprintf(file, "struct " #TYPENAME "\n{\n");
    #define STRUCTURED_BUFFER_FIELD(NAME, TYPE) fprintf(file,"  " #TYPE " " #NAME ";\n");
    #define STRUCTURED_BUFFER_END fprintf(file, "};\n\n");
    #include "ShaderTypesList.h"

    // write the structured buffer declarations
    fprintf(file, "//----------------------------------------------------------------------------\n//Structured Buffers\n//----------------------------------------------------------------------------\n");
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) fprintf(file, "StructuredBuffer<" #TYPENAME "> " #NAME ";\nRWStructuredBuffer<" #TYPENAME "> " #NAME "_rw;\n\n");
    #include "ShaderTypesList.h"

    fclose(file);
    return true;
}

template <EShaderType SHADER_TYPE>
void UnbindShaderTextures (ID3D11DeviceContext* deviceContext, ID3D11ShaderReflection* reflector)
{
    D3D11_SHADER_INPUT_BIND_DESC desc;
    HRESULT result;

    // reflect textures
    #define TEXTURE_IMAGE(NAME, FILENAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = nullptr; \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = nullptr; \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #define TEXTURE_VOLUME_BEGIN(NAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } 

    #define TEXTURE_ARRAY_BEGIN(NAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } 

    // reflect structured buffers
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = nullptr; \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #include "ShaderTypesList.h"
}

template <EShaderType SHADER_TYPE>
void FillShaderParams (ID3D11DeviceContext* deviceContext, ID3D11ShaderReflection* reflector)
{
    D3D11_SHADER_INPUT_BIND_DESC desc;
    HRESULT result;

    // reflect constant buffers
    #define CONSTANT_BUFFER_BEGIN(NAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11Buffer* buffer = ShaderData::ConstantBuffers::##NAME.Get(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetConstantBuffers(desc.BindPoint, 1, &buffer); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetConstantBuffers(desc.BindPoint, 1, &buffer); \
            else \
                deviceContext->CSSetConstantBuffers(desc.BindPoint, 1, &buffer); \
        }
    
    // reflect structured buffers
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::StructuredBuffers::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = ShaderData::StructuredBuffers::##NAME.GetUAV(); \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    // reflect textures
    #define TEXTURE_IMAGE(NAME, FILENAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::Textures::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = ShaderData::Textures::##NAME.GetUAV(); \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::Textures::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = ShaderData::Textures::##NAME.GetUAV(); \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #define TEXTURE_VOLUME_BEGIN(NAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::Textures::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        }

    #define TEXTURE_ARRAY_BEGIN(NAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::Textures::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        }

    #include "ShaderTypesList.h"

    // hard coded samplers
    result = reflector->GetResourceBindingDescByName("SamplerLinearWrap", &desc);
    if (!FAILED(result))
    {
        ID3D11SamplerState* sampler = g_d3d.SamplerLinearWrap();
        if (SHADER_TYPE == EShaderType::vertex)
            deviceContext->VSSetSamplers(desc.BindPoint, 1, &sampler);
        else if (SHADER_TYPE == EShaderType::pixel)
            deviceContext->PSSetSamplers(desc.BindPoint, 1, &sampler);
        else
            deviceContext->CSSetSamplers(desc.BindPoint, 1, &sampler);
    }
    result = reflector->GetResourceBindingDescByName("SamplerNearestWrap", &desc);
    if (!FAILED(result))
    {
        ID3D11SamplerState* sampler = g_d3d.SamplerNearestWrap();
        if (SHADER_TYPE == EShaderType::vertex)
            deviceContext->VSSetSamplers(desc.BindPoint, 1, &sampler);
        else if (SHADER_TYPE == EShaderType::pixel)
            deviceContext->PSSetSamplers(desc.BindPoint, 1, &sampler);
        else
            deviceContext->CSSetSamplers(desc.BindPoint, 1, &sampler);
    }
    result = reflector->GetResourceBindingDescByName("SamplerAnisoWrap", &desc);
    if (!FAILED(result))
    {
        ID3D11SamplerState* sampler = g_d3d.SamplerAnisoWrap();
        if (SHADER_TYPE == EShaderType::vertex)
            deviceContext->VSSetSamplers(desc.BindPoint, 1, &sampler);
        else if (SHADER_TYPE == EShaderType::pixel)
            deviceContext->PSSetSamplers(desc.BindPoint, 1, &sampler);
        else
            deviceContext->CSSetSamplers(desc.BindPoint, 1, &sampler);
    }
}

void IMGUIRenderFunction(ImDrawData* draw_data)
{
    // make sure our vertex and index buffers are large enough
    if (g_IMGUIMesh.GetIndexCount() < draw_data->TotalIdxCount || g_IMGUIMesh.GetIndexCount() < draw_data->TotalVtxCount)
    {
        // TODO: assert or something. or resize!
        ((int*)0)[0] = 0;
    }

    // copy all the vertex and index data into one buffer
    g_IMGUIMesh.Write(
        g_d3d.Context(),
        [&] (std::vector<ShaderTypes::VertexFormats::IMGUI>& vertexData, std::vector<unsigned long>& indexData)
        {
            ImDrawVert* vtx_dst = (ImDrawVert*)&vertexData[0];
            ImDrawIdx* idx_dst = (ImDrawIdx*)&indexData[0];

            for (int n = 0; n < draw_data->CmdListsCount; n++)
            {
                const ImDrawList* cmd_list = draw_data->CmdLists[n];
                memcpy(vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof(ImDrawVert));
                memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
                vtx_dst += cmd_list->VtxBuffer.Size;
                idx_dst += cmd_list->IdxBuffer.Size;
            }
        }
    );

    // setup shader
    const CShader& IMGUI = ShaderData::GetShader_IMGUI({});
    IMGUI.Set(g_d3d.Context());
    FillShaderParams<EShaderType::vertex>(g_d3d.Context(), IMGUI.GetVSReflector());
    FillShaderParams<EShaderType::pixel>(g_d3d.Context(), IMGUI.GetPSReflector());

    // Usually you'd setup render states but the render states it wants are the same that we use.
    // render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
    size_t vtx_offset = 0;
    size_t idx_offset = 0;
    g_d3d.EnableAlphaBlend(true);
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        ImDrawList* cmd_list = draw_data->CmdLists[n];
        
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback)
            {
                pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                // set scissor rect
                g_d3d.SetScissor((size_t)pcmd->ClipRect.x, (size_t)pcmd->ClipRect.y, (size_t)pcmd->ClipRect.z, (size_t)pcmd->ClipRect.w);

                // bind the texture
                CTexture* texture = (CTexture*)pcmd->TextureId;
                ID3D11ShaderResourceView* srv = texture->GetSRV();
                g_d3d.Context()->PSSetShaderResources(0, 1, &srv);

                // draw the mesh
                g_IMGUIMesh.Set(g_d3d.Context());
                g_d3d.DrawIndexed(pcmd->ElemCount, idx_offset, vtx_offset);
            }
            idx_offset += pcmd->ElemCount;
        }
        vtx_offset += cmd_list->VtxBuffer.Size;
    }

    // reset scissor and unbind the texture
    g_d3d.ClearScissor();
    ID3D11ShaderResourceView* srv = nullptr;
    g_d3d.Context()->PSSetShaderResources(0, 1, &srv);
    g_d3d.EnableAlphaBlend(false);
}

bool InitIMGUI()
{
    if (!QueryPerformanceFrequency((LARGE_INTEGER *)&g_TicksPerSecond))
        return false;
    if (!QueryPerformanceCounter((LARGE_INTEGER *)&g_Time))
        return false;

    ImGuiIO& io = ImGui::GetIO();
    io.DisplaySize.x = c_width;
    io.DisplaySize.y = c_height;
    io.KeyMap[ImGuiKey_Tab] = VK_TAB;                       // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array that we will update during the application lifetime.
    io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;
    io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;
    io.KeyMap[ImGuiKey_UpArrow] = VK_UP;
    io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;
    io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;
    io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;
    io.KeyMap[ImGuiKey_Home] = VK_HOME;
    io.KeyMap[ImGuiKey_End] = VK_END;
    io.KeyMap[ImGuiKey_Delete] = VK_DELETE;
    io.KeyMap[ImGuiKey_Backspace] = VK_BACK;
    io.KeyMap[ImGuiKey_Enter] = VK_RETURN;
    io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;
    io.KeyMap[ImGuiKey_Delete] = VK_DELETE;
    io.KeyMap[ImGuiKey_A] = 'A';
    io.KeyMap[ImGuiKey_C] = 'C';
    io.KeyMap[ImGuiKey_V] = 'V';
    io.KeyMap[ImGuiKey_X] = 'X';
    io.KeyMap[ImGuiKey_Y] = 'Y';
    io.KeyMap[ImGuiKey_Z] = 'Z';

    io.RenderDrawListsFn = IMGUIRenderFunction;  // Alternatively you can set this to NULL and call ImGui::GetDrawData() after ImGui::Render() to get the same ImDrawData pointer.
    io.ImeWindowHandle = WindowGetHWND();

    // Load texture atlas (there is a default font so you don't need to care about choosing a font yet)
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
    if (!g_IMGUIFont.LoadFromPixels(g_d3d.Device(), g_d3d.Context(), pixels, width, height))
        return false;

    // Store texture pointer/identifier (whatever your engine uses) in 'io.Fonts->TexID'. This will be passed back to your via the renderer.
    io.Fonts->TexID = (void*)&g_IMGUIFont;
    return true;
}

void ReportError (const char* message)
{
    OutputDebugStringA(message);
    fprintf(stderr, message);
}

bool init ()
{
    WindowInit(c_width, c_height, c_fullScreen);

    if (!g_d3d.Init(c_width, c_height, c_vsync, WindowGetHWND(), c_fullScreen, c_d3ddebug))
        return false;

    if (!WriteShaderTypesHLSL())
        return false;

    // create constant buffers
    #define CONSTANT_BUFFER_BEGIN(NAME) if (!ShaderData::ConstantBuffers::NAME.Create(g_d3d.Device())) { ReportError("Could not create constant buffer: " #NAME "\n"); return false; }
    #include "ShaderTypesList.h"

    // create structured buffers
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) if (!ShaderData::StructuredBuffers::NAME.Create(g_d3d.Device(), CPUWRITES)) { ReportError("Could not create structured buffer: " #NAME "\n"); return false; }
    #include "ShaderTypesList.h"

    // create textures
    #define TEXTURE_IMAGE(NAME, FILENAME) \
        if(!ShaderData::Textures::NAME.LoadTGA(g_d3d.Device(), g_d3d.Context(), FILENAME)) { ReportError("Could not load texture: " #NAME "\n"); return false; }
    #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) \
        if(!ShaderData::Textures::NAME.Create(g_d3d.Device(), g_d3d.Context(), c_width, c_height, FORMAT)) { ReportError("Could not create texture buffer: " #NAME "\n"); return false; }
    #include "ShaderTypesList.h"

    // create volume textures and texture arrays
    #define TEXTURE_VOLUME_BEGIN(NAME) CTexture* slices##NAME [] = {
    #define TEXTURE_VOLUME_SLICE(TEXTURE) &ShaderData::Textures::##TEXTURE,
    #define TEXTURE_VOLUME_END };
    #define TEXTURE_ARRAY_BEGIN(NAME) CTexture* slices##NAME [] = {
    #define TEXTURE_ARRAY_SLICE(TEXTURE) &ShaderData::Textures::##TEXTURE,
    #define TEXTURE_ARRAY_END };
    #include "ShaderTypesList.h"

    #define TEXTURE_VOLUME_BEGIN(NAME) \
        size_t numSlices##NAME = sizeof(slices##NAME) / sizeof(slices##NAME[0]);\
        if (!ShaderData::Textures::NAME.CreateVolume(g_d3d.Device(), g_d3d.Context(), slices##NAME, numSlices##NAME)) { ReportError("Could not create volume texture: " #NAME "\n"); return false; }
    #define TEXTURE_ARRAY_BEGIN(NAME) \
        size_t numSlices##NAME = sizeof(slices##NAME) / sizeof(slices##NAME[0]);\
        if (!ShaderData::Textures::NAME.CreateArray(g_d3d.Device(), g_d3d.Context(), slices##NAME, numSlices##NAME)) { ReportError("Could not create texture array: " #NAME "\n"); return false; }
    #include "ShaderTypesList.h"

    // create shaders
    #define SHADER_CS_BEGIN(NAME, FILENAME, ENTRY) \
    { \
        static_assert((uint32_t)ShaderData::Shaders::EStaticBranches_CS_##NAME::COUNT <= 32, "Too many static branches in CS shader: "#NAME); \
        uint64_t maxValue = (uint64_t)1 << ((uint64_t)ShaderData::Shaders::EStaticBranches_CS_##NAME::COUNT); \
        for (uint64_t i = 0; i < maxValue; ++i) \
        { \
            ShaderData::WriteStaticBranches_CS_##NAME(i); \
            if (!ShaderData::Shaders::NAME[i].Load(g_d3d.Device(), WindowGetHWND(), FILENAME, ENTRY, c_shaderDebug)) { ReportError("Could not create compute shader: " #NAME "\n"); return false; } \
        } \
    }
    #define SHADER_VSPS_BEGIN(NAME, FILENAME, VSENTRY, PSENTRY, VERTEXFORMAT) \
    { \
        static_assert((uint32_t)ShaderData::Shaders::EStaticBranches_VSPS_##NAME::COUNT <= 32, "Too many static branches in VSPS shader: "#NAME); \
        uint64_t maxValue = (uint64_t)1 << ((uint64_t)ShaderData::Shaders::EStaticBranches_VSPS_##NAME::COUNT); \
        for (uint64_t i = 0; i < maxValue; ++i) \
        { \
            ShaderData::WriteStaticBranches_VSPS_##NAME(i); \
            if (!ShaderData::Shaders::NAME[i].Load(g_d3d.Device(), WindowGetHWND(), FILENAME, VSENTRY, PSENTRY, ShaderData::VertexFormats::VERTEXFORMAT, ShaderData::VertexFormats::VERTEXFORMAT##Elements, c_shaderDebug)) { ReportError("Could not create shader : " #NAME "\n"); return false; } \
        } \
    }
    #include "ShaderTypesList.h"

    // make a full screen triangle
   bool writeOK = g_fullScreenMesh.Create(
        g_d3d.Device(),
        [] (std::vector<ShaderTypes::VertexFormats::Pos2D>& vertexData, std::vector<unsigned long>& indexData)
        {
            vertexData.resize(3);
            indexData.resize(3);

            vertexData[0] = { -1.0f,  3.0f, 0.0f, 1.0f };
            vertexData[1] = {  3.0f, -1.0f, 0.0f, 1.0f };
            vertexData[2] = { -1.0f, -1.0f, 0.0f, 1.0f };

            indexData[0] = 0;
            indexData[1] = 1;
            indexData[2] = 2;
        }
    );

    if (!writeOK)
    {
        ReportError("Could not create full screen triangle\n");
        return false;
    }

    writeOK = g_IMGUIMesh.Create(
        g_d3d.Device(),
        [] (std::vector<ShaderTypes::VertexFormats::IMGUI>& vertexData, std::vector<unsigned long>& indexData)
        {
            vertexData.resize(c_IMGUI_Verts);
            indexData.resize(c_IMGUI_Verts);

            for (size_t i = 0; i < c_IMGUI_Verts; ++i)
                indexData[i] = (unsigned long) i;
        }
    );

    if (!writeOK)
    {
        ReportError("Could not create fullimgui mesh\n");
        return false;
    }

    writeOK = ShaderData::ConstantBuffers::ConstantsOnce.Write(
        g_d3d.Context(),
        [] (ShaderTypes::ConstantBuffers::ConstantsOnce& data)
        {
            data.width_height_zw = { float(c_width), float(c_height), 0.0f, 0.0f };
            data.cameraPos_FOVX = { 0.0f, 0.0f, 0.0f, c_fovX };
            data.cameraAt_FOVY = { 0.0f, 0.0f, 0.0f, c_fovY };
            data.nearPlaneDist_missColor = { 0.0f, 0.0f, 0.0f, 0.0f };
            data.numSpheres_numTris_numOBBs_numQuads = { 0, 0, 0, 0 };
			data.uvmultiplier_blackPoint_whitePoint_w = { 1.0f, 0.0f, 1.0f, 0.0f };
        }
    );
    if (!writeOK)
    {
        ReportError("Could not write constants once\n");
        return false;
    }

    writeOK = ShaderData::ConstantBuffers::ConstantsPerFrame.Write(
        g_d3d.Context(),
        [] (ShaderTypes::ConstantBuffers::ConstantsPerFrame& data)
        {
            data.frameRnd_appTime_zw = { 0.0f, 0.0f, 0.0f, 0.0f };
            data.sampleCount_yzw = {0, 0, 0, 0};
        }
    );
    if (!writeOK)
    {
        ReportError("Could not write constants per frame\n");
        return false;
    }

    if (!InitIMGUI())
    {
        ReportError("Could not init imgui\n");
        return false;
    }

    return true;
}

void IMGUIWindow ()
{
    // calculate frame time
    INT64 current_time;
    QueryPerformanceCounter((LARGE_INTEGER *)&current_time);
    float deltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;

    // set delta time and current time
    ImGuiIO& io = ImGui::GetIO();
    io.DeltaTime = deltaTime;
    g_Time = current_time;

    // start a new frame
    ImGui::NewFrame();

    // used to see the fully featured built in imgui demo window
    if (0)
    {
        ImGui::ShowTestWindow();
        return;
    }

    // handle FPS calculations
    static int FPSFrameCount = 0;
    static float FPSFrameTime = 0.0f;
    static float FPSLast = 0.0f;
    FPSFrameCount++;
    FPSFrameTime += deltaTime;
    if (FPSFrameTime > 0.5f)
    {
        FPSLast = float(FPSFrameCount) / FPSFrameTime;
        FPSFrameCount = 0;
        FPSFrameTime = 0.0f;
    }

    // handle UI
    static bool firstTime = true;

    static float uvScale = 1.0f;
    static float blackPoint = 0.0f;
    static float whitePoint = 1.0f;
    static int scene = 0;

    bool updateConstants = false;
    bool updateScene = false;

    if (firstTime)
    {
        uvScale = ShaderData::ConstantBuffers::ConstantsOnce.Read().uvmultiplier_blackPoint_whitePoint_w[0];
        blackPoint = ShaderData::ConstantBuffers::ConstantsOnce.Read().uvmultiplier_blackPoint_whitePoint_w[1];
        whitePoint = ShaderData::ConstantBuffers::ConstantsOnce.Read().uvmultiplier_blackPoint_whitePoint_w[2];
    }

    ImGui::Begin("", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar);

    const char* scenes[] = {
        "Sphere Plane Dark",
        "Sphere Plane Light",
        "Cornell Box Small Light",
        "Cornell Box Big Light",
        "Furnace Test",
        "Cornell Obj",
        "Obj Test"
    };

    if (ImGui::CollapsingHeader("Scene", ImGuiTreeNodeFlags_DefaultOpen))
    {
        updateScene |= ImGui::Combo("Scene", &scene, scenes, (int)EScene::COUNT);
        updateScene |= ImGui::Checkbox("White Albedo", &g_whiteAlbedo);
        if (ImGui::Button("Reset Render"))
        {
            ShaderData::ConstantBuffers::ConstantsPerFrame.Write(
                g_d3d.Context(),
                [=](ShaderTypes::ConstantBuffers::ConstantsPerFrame& data)
                {
                    data.sampleCount_yzw[0] = 0;
                }
            );
        }
    }

    if (ImGui::CollapsingHeader("Cross Hatching", ImGuiTreeNodeFlags_DefaultOpen))
    {
        ImGui::Checkbox("Grey Scale", &g_showGrey);
        ImGui::Checkbox("Cross Hatch", &g_showCrossHatch);
        ImGui::Checkbox("16x Anisotropic Sampling", &g_aniso);
        updateConstants |= ImGui::SliderFloat("UV Scale", &uvScale, 0.001f, 3.0f);
    }

    if (ImGui::CollapsingHeader("Brightness", ImGuiTreeNodeFlags_DefaultOpen))
    {
        updateConstants |= ImGui::SliderFloat("Black", &blackPoint, 0.0f, 1.0f);
        updateConstants |= ImGui::SliderFloat("White", &whitePoint, 0.0f, 1.0f);
        ImGui::Checkbox("Smooth Step Brightness", &g_smoothStep);
    }

    if (ImGui::CollapsingHeader("Stats", ImGuiTreeNodeFlags_DefaultOpen))
    {
        uint4 counts = ShaderData::ConstantBuffers::ConstantsOnce.Read().numSpheres_numTris_numOBBs_numQuads;
        ImGui::Text("Rendering at %u x %u\nSpheres: %u\nTriangles: %u\nOBBs: %u\nQuads: %u\n", c_width, c_height, counts[0], counts[1], counts[2], counts[3]);
        ImGui::Text("FPS: %0.2f (%0.2f ms)", FPSLast, FPSLast > 0 ? 1000.0f / FPSLast : 0.0f);
        ImGui::Text("%u samples\nFPS is samples per second\n", ShaderData::ConstantBuffers::ConstantsPerFrame.Read().sampleCount_yzw[0]);
        ImGui::Separator();
    }

    // show FPS
    ImGui::Text("Press 'H' to hide or unhide this window. Escape to exit.");

    ImGui::End();

    // update constants
    if (updateConstants)
    {
        ShaderData::ConstantBuffers::ConstantsOnce.Write(
            g_d3d.Context(),
            [=](ShaderTypes::ConstantBuffers::ConstantsOnce& data)
            {
                data.uvmultiplier_blackPoint_whitePoint_w[0] = uvScale;
                data.uvmultiplier_blackPoint_whitePoint_w[1] = blackPoint;
                data.uvmultiplier_blackPoint_whitePoint_w[2] = whitePoint;
            }
        );
    }

    if (updateScene)
    {
        FillSceneData((EScene)scene, g_d3d.Context());

        uvScale = ShaderData::ConstantBuffers::ConstantsOnce.Read().uvmultiplier_blackPoint_whitePoint_w[0];
        blackPoint = ShaderData::ConstantBuffers::ConstantsOnce.Read().uvmultiplier_blackPoint_whitePoint_w[1];
        whitePoint = ShaderData::ConstantBuffers::ConstantsOnce.Read().uvmultiplier_blackPoint_whitePoint_w[2];
    }
}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pScmdline, int iCmdshow)
{
    std::chrono::high_resolution_clock::time_point appStart = std::chrono::high_resolution_clock::now();

    if (!init())
        return 0;

    const size_t dispatchX = 1 + c_width / 32;
    const size_t dispatchY = 1 + c_height / 32;

    FillSceneData(EScene::SphereOnPlane_LowLight, g_d3d.Context());

    bool done = false;
    while (!done)
    {
        // Handle the windows messages.
        MSG msg;
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        // If windows signals to end the application then exit out.
        if (msg.message == WM_QUIT)
        {
            done = true;
        }
        else
        {

            IMGUIWindow();


            // update frame specific values
			bool firstSample = false;
            std::chrono::duration<float> appTimeSeconds = std::chrono::high_resolution_clock::now() - appStart;
            bool writeOK = ShaderData::ConstantBuffers::ConstantsPerFrame.Write(
                g_d3d.Context(),
                [&firstSample, &appTimeSeconds] (ShaderTypes::ConstantBuffers::ConstantsPerFrame& data)
                {
                    data.frameRnd_appTime_zw[0] = RandomFloat(0.0f, 1.0f);
                    data.frameRnd_appTime_zw[1] = appTimeSeconds.count();

                    data.sampleCount_yzw[0]++;

					firstSample = (data.sampleCount_yzw[0] == 1);
                }
            );
            if (!writeOK)
                done = true;

			// if this is sample 0, we need to run the code that generates the first intersection that is re-used by the path tracing and the shader that shows the path tracing results
			if (firstSample)
			{
                const CComputeShader& shader = ShaderData::GetShader_pathTraceFirstHit({});
                FillShaderParams<EShaderType::compute>(g_d3d.Context(), shader.GetReflector());
                shader.Dispatch(g_d3d.Context(), dispatchX, dispatchY, 1);
                UnbindShaderTextures<EShaderType::compute>(g_d3d.Context(), shader.GetReflector());
			}

            // path tracing compute shader
            const CComputeShader& computeShader = ShaderData::GetShader_pathTrace({g_whiteAlbedo});
            FillShaderParams<EShaderType::compute>(g_d3d.Context(), computeShader.GetReflector());
            computeShader.Dispatch(g_d3d.Context(), dispatchX, dispatchY, 1);
            UnbindShaderTextures<EShaderType::compute>(g_d3d.Context(), computeShader.GetReflector());

            // TODO: it really would be nice if passing static branches would let you see names. Maybe a function that returns the correct type? Also make sure that all parameters are required. No silent failures!

            // vs/ps to show the results of the path tracing
            const CShader& shader = ShaderData::GetShader_showPathTrace({g_showGrey, g_showCrossHatch, g_smoothStep, g_aniso});
            FillShaderParams<EShaderType::vertex>(g_d3d.Context(), shader.GetVSReflector());
            FillShaderParams<EShaderType::pixel>(g_d3d.Context(), shader.GetPSReflector());
            g_fullScreenMesh.Set(g_d3d.Context());
            shader.Set(g_d3d.Context());
            g_d3d.DrawIndexed(g_fullScreenMesh.GetIndexCount());
            UnbindShaderTextures<EShaderType::vertex>(g_d3d.Context(), shader.GetVSReflector());
            UnbindShaderTextures<EShaderType::pixel>(g_d3d.Context(), shader.GetPSReflector());

            // render imgui
            ImGui::Render();

            g_d3d.Present();
        }
    }

    return 0;
}