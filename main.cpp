#define _CRT_SECURE_NO_WARNINGS

#include <chrono>
#include <random>
#include "d3d11.h"
#include "Shader.h"
#include "Model.h"
#include "Texture.h"
#include "Window.h"
#include "ShaderTypes.h"
#include "ConstantBuffer.h"
#include "StructuredBuffer.h"
#include "Scenes.h"
#include "imgui/imgui.h"

// globals
CD3D11 g_d3d;

bool g_showGrey = false;
bool g_showCrossHatch = false;
bool g_smoothStep = false;

CModel<ShaderTypes::VertexFormats::Pos2D> g_fullScreenMesh;

float RandomFloat (float min, float max)
{
    static std::random_device rd;
    static std::mt19937 mt(rd());
    std::uniform_real_distribution<float> dist(min, max);
    return dist(mt);
}

// automatically reflected things for shaders
namespace ShaderData
{
    namespace ConstantBuffers
    {
        #define CONSTANT_BUFFER_BEGIN(NAME) CConstantBuffer<ShaderTypes::ConstantBuffers::##NAME> NAME;
        #include "ShaderTypesList.h"
    };

    namespace StructuredBuffers
    {
        #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) CStructuredBuffer<ShaderTypes::StructuredBuffers::##TYPENAME, COUNT> NAME;
        #include "ShaderTypesList.h"
    };

    namespace Textures
    {
        #define TEXTURE_IMAGE(NAME, FILENAME) CTexture NAME;
        #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) CTexture NAME;
        #define TEXTURE_VOLUME_BEGIN(NAME) CTexture NAME;
        #include "ShaderTypesList.h"
    }

    namespace Shaders
    {
        #define SHADER_CS(NAME, FILENAME, ENTRY) CComputeShader NAME;
        #define SHADER_VSPS(NAME, FILENAME, VSENTRY, PSENTRY, VERTEXFORMAT) CShader NAME;
        #include "ShaderTypesList.h"
    };

    namespace VertexFormats
    {
        #define VERTEX_FORMAT_BEGIN(NAME) D3D11_INPUT_ELEMENT_DESC NAME [] = {
        #define VERTEX_FORMAT_FIELD(NAME, SEMANTIC, INDEX, TYPE, FORMAT) \
            {#SEMANTIC, INDEX, FORMAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0},
        #define VERTEX_FORMAT_END };
        #include "ShaderTypesList.h"

        #define VERTEX_FORMAT_BEGIN(NAME) size_t NAME##Elements = sizeof(NAME) / sizeof(NAME[0]);
        #include "ShaderTypesList.h"
    }
};

// generate shader code ShaderTypes.h
bool WriteShaderTypesHLSL (void)
{
    FILE *file = fopen("Shaders/ShaderTypes.h", "w+t");
    if (!file)
        return false;

    fprintf(file, "//This file is autogenerated by WriteShaderTypesHLSL(), using ShaderTypesList.h as source data\n\n");

    // hard coded sampler states
    fprintf(file, "//----------------------------------------------------------------------------\n//Samplers\n//----------------------------------------------------------------------------\n");
    fprintf(file, "SamplerState SamplerLinearWrap;\nSamplerState SamplerNearestWrap;\nSamplerState SamplerAnisoWrap;\n\n");

    // write the texture declarations
    fprintf(file, "//----------------------------------------------------------------------------\n//Textures\n//----------------------------------------------------------------------------\n");
    #define TEXTURE_IMAGE(NAME, FILENAME) fprintf(file, "Texture2D " #NAME ";\nRWTexture2D<float4> " #NAME "_rw;\n\n");
    #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) fprintf(file, "Texture2D " #NAME ";\nRWTexture2D<" #SHADERTYPE "> " #NAME "_rw;\n\n");
    #define TEXTURE_VOLUME_BEGIN(NAME) fprintf(file, "Texture3D " #NAME ";\n\n");
    #include "ShaderTypesList.h"

    // write the cbuffer declarations
    fprintf(file, "//----------------------------------------------------------------------------\n//Constant Buffers\n//----------------------------------------------------------------------------\n");
    #define CONSTANT_BUFFER_BEGIN(NAME) fprintf(file, "cbuffer " #NAME "\n{\n");
    #define CONSTANT_BUFFER_FIELD(NAME, TYPE) fprintf(file,"  " #TYPE " " #NAME ";\n");
    #define CONSTANT_BUFFER_END fprintf(file, "};\n\n");
    #include "ShaderTypesList.h"

    // write the vertex formats
    fprintf(file, "//----------------------------------------------------------------------------\n//Vertex Formats\n//----------------------------------------------------------------------------\n");
    #define VERTEX_FORMAT_BEGIN(NAME) fprintf(file, "struct " #NAME "\n{\n");
    #define VERTEX_FORMAT_FIELD(NAME, SEMANTIC, INDEX, TYPE, FORMAT) fprintf(file, "  " #TYPE " " #NAME " : " #SEMANTIC #INDEX ";\n");
    #define VERTEX_FORMAT_END fprintf(file, "};\n\n");
    #include "ShaderTypesList.h"

    // write the struct declarations for structured buffers
    fprintf(file, "//----------------------------------------------------------------------------\n//Structured Buffer Types\n//----------------------------------------------------------------------------\n");
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) fprintf(file, "struct " #TYPENAME "\n{\n");
    #define STRUCTURED_BUFFER_FIELD(NAME, TYPE) fprintf(file,"  " #TYPE " " #NAME ";\n");
    #define STRUCTURED_BUFFER_END fprintf(file, "};\n\n");
    #include "ShaderTypesList.h"

    // write the structured buffer declarations
    fprintf(file, "//----------------------------------------------------------------------------\n//Structured Buffers\n//----------------------------------------------------------------------------\n");
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) fprintf(file, "StructuredBuffer<" #TYPENAME "> " #NAME ";\nRWStructuredBuffer<" #TYPENAME "> " #NAME "_rw;\n\n");
    #include "ShaderTypesList.h"

    fclose(file);
    return true;
}

template <EShaderType SHADER_TYPE>
void UnbindShaderTextures (ID3D11DeviceContext* deviceContext, ID3D11ShaderReflection* reflector)
{
    D3D11_SHADER_INPUT_BIND_DESC desc;
    HRESULT result;

    // reflect textures
    #define TEXTURE_IMAGE(NAME, FILENAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = nullptr; \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = nullptr; \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #define TEXTURE_VOLUME_BEGIN(NAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } 

    // reflect structured buffers
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = nullptr; \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = nullptr; \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #include "ShaderTypesList.h"
}

template <EShaderType SHADER_TYPE>
void FillShaderParams (ID3D11DeviceContext* deviceContext, ID3D11ShaderReflection* reflector)
{
    D3D11_SHADER_INPUT_BIND_DESC desc;
    HRESULT result;

    // reflect constant buffers
    #define CONSTANT_BUFFER_BEGIN(NAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11Buffer* buffer = ShaderData::ConstantBuffers::##NAME.Get(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetConstantBuffers(desc.BindPoint, 1, &buffer); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetConstantBuffers(desc.BindPoint, 1, &buffer); \
            else \
                deviceContext->CSSetConstantBuffers(desc.BindPoint, 1, &buffer); \
        }
    
    // reflect structured buffers
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::StructuredBuffers::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = ShaderData::StructuredBuffers::##NAME.GetUAV(); \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    // reflect textures
    #define TEXTURE_IMAGE(NAME, FILENAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::Textures::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = ShaderData::Textures::##NAME.GetUAV(); \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::Textures::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        } \
        result = reflector->GetResourceBindingDescByName(#NAME "_rw", &desc); \
        if (!FAILED(result)) { \
            UINT count = -1; \
            ID3D11UnorderedAccessView* uav = ShaderData::Textures::##NAME.GetUAV(); \
            if (SHADER_TYPE == EShaderType::compute) \
                deviceContext->CSSetUnorderedAccessViews(desc.BindPoint, 1, &uav, &count); \
        }

    #define TEXTURE_VOLUME_BEGIN(NAME) \
        result = reflector->GetResourceBindingDescByName(#NAME, &desc); \
        if (!FAILED(result)) { \
            ID3D11ShaderResourceView* srv = ShaderData::Textures::##NAME.GetSRV(); \
            if (SHADER_TYPE == EShaderType::vertex) \
                deviceContext->VSSetShaderResources(desc.BindPoint, 1, &srv); \
            else if (SHADER_TYPE == EShaderType::pixel) \
                deviceContext->PSSetShaderResources(desc.BindPoint, 1, &srv); \
            else \
                deviceContext->CSSetShaderResources(desc.BindPoint, 1, &srv); \
        }

    #include "ShaderTypesList.h"

    // hard coded samplers
    result = reflector->GetResourceBindingDescByName("SamplerLinearWrap", &desc);
    if (!FAILED(result))
    {
        ID3D11SamplerState* sampler = g_d3d.SamplerLinearWrap();
        if (SHADER_TYPE == EShaderType::vertex)
            deviceContext->VSSetSamplers(desc.BindPoint, 1, &sampler);
        else if (SHADER_TYPE == EShaderType::pixel)
            deviceContext->PSSetSamplers(desc.BindPoint, 1, &sampler);
        else
            deviceContext->CSSetSamplers(desc.BindPoint, 1, &sampler);
    }
    result = reflector->GetResourceBindingDescByName("SamplerNearestWrap", &desc);
    if (!FAILED(result))
    {
        ID3D11SamplerState* sampler = g_d3d.SamplerNearestWrap();
        if (SHADER_TYPE == EShaderType::vertex)
            deviceContext->VSSetSamplers(desc.BindPoint, 1, &sampler);
        else if (SHADER_TYPE == EShaderType::pixel)
            deviceContext->PSSetSamplers(desc.BindPoint, 1, &sampler);
        else
            deviceContext->CSSetSamplers(desc.BindPoint, 1, &sampler);
    }
    result = reflector->GetResourceBindingDescByName("SamplerAnisoWrap", &desc);
    if (!FAILED(result))
    {
        ID3D11SamplerState* sampler = g_d3d.SamplerAnisoWrap();
        if (SHADER_TYPE == EShaderType::vertex)
            deviceContext->VSSetSamplers(desc.BindPoint, 1, &sampler);
        else if (SHADER_TYPE == EShaderType::pixel)
            deviceContext->PSSetSamplers(desc.BindPoint, 1, &sampler);
        else
            deviceContext->CSSetSamplers(desc.BindPoint, 1, &sampler);
    }
}

void OnKeyPress (unsigned char key, bool pressed)
{
    // only do actions on key release right now
    if (pressed)
        return;

    switch (key)
    {
        case '1': FillSceneData(EScene::SphereOnPlane_LowLight, g_d3d.Context()); break;
        case '2': FillSceneData(EScene::SphereOnPlane_RegularLight, g_d3d.Context()); break;
        case '3': FillSceneData(EScene::CornellBox_SmallLight, g_d3d.Context()); break;
        case '4': FillSceneData(EScene::CornellBox_BigLight, g_d3d.Context()); break;
        case '5': FillSceneData(EScene::FurnaceTest, g_d3d.Context()); break;
        case '6': FillSceneData(EScene::CornellObj, g_d3d.Context()); break;
        case '7': FillSceneData(EScene::ObjTest, g_d3d.Context()); break;

        case 'Q': g_showCrossHatch = !g_showCrossHatch; break;
        case 'W': g_showGrey = !g_showGrey; break;
        case 'E': g_smoothStep = !g_smoothStep; break;
        case 'A': 
        {
            ShaderData::ConstantBuffers::ConstantsOnce.Write(
                g_d3d.Context(),
                [] (ShaderTypes::ConstantBuffers::ConstantsOnce& data)
                {
                    data.uvmultiplier_blackPoint_whitePoint_w[1] += 0.1f;
                }
            );
            break;
        }
        case 'S': 
        {
            ShaderData::ConstantBuffers::ConstantsOnce.Write(
                g_d3d.Context(),
                [] (ShaderTypes::ConstantBuffers::ConstantsOnce& data)
                {
                    data.uvmultiplier_blackPoint_whitePoint_w[1] -= 0.1f;
                }
            );
            break;
        }
        case 'D': 
        {
            ShaderData::ConstantBuffers::ConstantsOnce.Write(
                g_d3d.Context(),
                [] (ShaderTypes::ConstantBuffers::ConstantsOnce& data)
                {
                    data.uvmultiplier_blackPoint_whitePoint_w[2] += 0.1f;
                }
            );
            break;
        }
        case 'F': 
        {
            ShaderData::ConstantBuffers::ConstantsOnce.Write(
                g_d3d.Context(),
                [] (ShaderTypes::ConstantBuffers::ConstantsOnce& data)
                {
                    data.uvmultiplier_blackPoint_whitePoint_w[2] -= 0.1f;
                }
            );
            break;
        }
    }
}

void MyRenderFunction(ImDrawData* draw_data)
{
    // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
    // TODO: Setup viewport, orthographic projection matrix
    // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        ImDrawList* cmd_list = draw_data->CmdLists[n];

        const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
        const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback)
            {
                pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                // TODO: this stuff
                // Render 'pcmd->ElemCount/3' texture triangles
                //MyEngineBindTexture(pcmd->TextureId);
                //MyEngineScissor((int)pcmd->ClipRect.x, (int)pcmd->ClipRect.y, (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y));
                //MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
            }
            idx_buffer += pcmd->ElemCount;
        }
    }
}

bool InitIMGUI()
{
    // TODO: move imgui to it's own file!
    ImGuiIO& io = ImGui::GetIO();
    io.DisplaySize.x = 1920.0f;
    io.DisplaySize.y = 1280.0f;
    // TODO: AW - render function!
    io.RenderDrawListsFn = MyRenderFunction;  // Setup a render function, or set to NULL and call GetDrawData() after Render() to access the render data.
    // TODO: Fill others settings of the io structure later.

    // Load texture atlas (there is a default font so you don't need to care about choosing a font yet)
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
    // TODO: At this points you've got the texture data and you need to upload that your your graphic system:
    CTexture* texture = new CTexture;
    if (!texture->LoadFromPixels(g_d3d.Device(), g_d3d.Context(), pixels, width, height))
        return false;

    //MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA)
    // TODO: Store your texture pointer/identifier (whatever your engine uses) in 'io.Fonts->TexID'. This will be passed back to your via the renderer.
    io.Fonts->TexID = (void*)texture;

    // TODO: delete CTexture later, or make it a shadertypelist.h item or something.
    return true;
}

bool init ()
{
    WindowInit(c_width, c_height, c_fullScreen, OnKeyPress);

    if (!g_d3d.Init(c_width, c_height, c_vsync, WindowGetHWND(), c_fullScreen, c_d3ddebug))
        return false;

    if (!WriteShaderTypesHLSL())
        return false;

    // create constant buffers
    #define CONSTANT_BUFFER_BEGIN(NAME) if (!ShaderData::ConstantBuffers::NAME.Create(g_d3d.Device())) return false;
    #include "ShaderTypesList.h"

    // create structured buffers
    #define STRUCTURED_BUFFER_BEGIN(NAME, TYPENAME, COUNT, CPUWRITES) if (!ShaderData::StructuredBuffers::NAME.Create(g_d3d.Device(), CPUWRITES)) return false;
    #include "ShaderTypesList.h"

    // create textures
    #define TEXTURE_IMAGE(NAME, FILENAME) \
        if(!ShaderData::Textures::NAME.LoadTGA(g_d3d.Device(), g_d3d.Context(), FILENAME)) return false;
    #define TEXTURE_BUFFER(NAME, SHADERTYPE, FORMAT) \
        if(!ShaderData::Textures::NAME.Create(g_d3d.Device(), g_d3d.Context(), c_width, c_height, FORMAT)) return false;
    #include "ShaderTypesList.h"

    // create volume textures
    #define TEXTURE_VOLUME_BEGIN(NAME) CTexture* slices##NAME [] = {
    #define TEXTURE_VOLUME_SLICE(TEXTURE) &ShaderData::Textures::##TEXTURE,
    #define TEXTURE_VOLUME_END };
    #include "ShaderTypesList.h"

    #define TEXTURE_VOLUME_BEGIN(NAME) \
        size_t numSlices##NAME = sizeof(slices##NAME) / sizeof(slices##NAME[0]);\
        if (!ShaderData::Textures::NAME.CreateVolume(g_d3d.Device(), g_d3d.Context(), slices##NAME, numSlices##NAME)) return false;
    #include "ShaderTypesList.h"

    //if (!crossHatching.CreateVolume(g_d3d.Device(), g_d3d.Context(), 193, 193, 9, slices, DXGI_FORMAT_R8G8B8A8_UNORM))
    //    return 0;

    // create shaders
    #define SHADER_CS(NAME, FILENAME, ENTRY) \
        if (!ShaderData::Shaders::NAME.Load(g_d3d.Device(), WindowGetHWND(), FILENAME, ENTRY, c_shaderDebug)) return false;
    #define SHADER_VSPS(NAME, FILENAME, VSENTRY, PSENTRY, VERTEXFORMAT) \
        if (!ShaderData::Shaders::NAME.Load(g_d3d.Device(), WindowGetHWND(), FILENAME, VSENTRY, PSENTRY, ShaderData::VertexFormats::VERTEXFORMAT, ShaderData::VertexFormats::VERTEXFORMAT##Elements, c_shaderDebug)) return false;
    #include "ShaderTypesList.h"

    // make a full screen triangle
   bool writeOK = g_fullScreenMesh.Create(
        g_d3d.Device(),
        [] (std::vector<ShaderTypes::VertexFormats::Pos2D>& vertexData, std::vector<unsigned long>& indexData)
        {
            vertexData.resize(3);
            indexData.resize(3);

            vertexData[0] = { -1.0f,  3.0f, 0.0f, 1.0f };
            vertexData[1] = {  3.0f, -1.0f, 0.0f, 1.0f };
            vertexData[2] = { -1.0f, -1.0f, 0.0f, 1.0f };

            indexData[0] = 0;
            indexData[1] = 1;
            indexData[2] = 2;
        }
    );

    writeOK = ShaderData::ConstantBuffers::ConstantsOnce.Write(
        g_d3d.Context(),
        [] (ShaderTypes::ConstantBuffers::ConstantsOnce& data)
        {
            data.cameraPos_FOVX = { 0.0f, 0.0f, 0.0f, c_fovX };
            data.cameraAt_FOVY = { 0.0f, 0.0f, 0.0f, c_fovY };
            data.nearPlaneDist_missColor = { 0.0f, 0.0f, 0.0f, 0.0f };
            data.numSpheres_numTris_numOBBs_numQuads = { 0, 0, 0, 0 };
			data.uvmultiplier_blackPoint_whitePoint_w = { 1.0f, 0.0f, 1.0f, 0.0f };
        }
    );
    if (!writeOK)
        return false;

    writeOK = ShaderData::ConstantBuffers::ConstantsPerFrame.Write(
        g_d3d.Context(),
        [] (ShaderTypes::ConstantBuffers::ConstantsPerFrame& data)
        {
            data.frameRnd_appTime_zw = { 0.0f, 0.0f, 0.0f, 0.0f };
            data.sampleCount_yzw = {0, 0, 0, 0};
        }
    );
    if (!writeOK)
        return false;

    if (!InitIMGUI())
        return false;

    return true;
}

CShader& SelectShaderShowPathTrace ()
{
    if (g_showGrey)
    {
        if (g_showCrossHatch)
        {
            if (g_smoothStep)
                return ShaderData::Shaders::showPathTrace_Grey_CrossHatch_SmoothStep;
            else
                return ShaderData::Shaders::showPathTrace_Grey_CrossHatch_No;
        }
        else
        {
            if (g_smoothStep)
                return ShaderData::Shaders::showPathTrace_Grey_Shade_SmoothStep;
            else
                return ShaderData::Shaders::showPathTrace_Grey_Shade_No;
        }
    }
    else
    {
        if (g_showCrossHatch)
        {
            if (g_smoothStep)
                return ShaderData::Shaders::showPathTrace_Color_CrossHatch_SmoothStep;
            else
                return ShaderData::Shaders::showPathTrace_Color_CrossHatch_No;
        }
        else
        {
            if (g_smoothStep)
                return ShaderData::Shaders::showPathTrace_Color_Shade_SmoothStep;
            else
                return ShaderData::Shaders::showPathTrace_Color_Shade_No;
        }
    }
}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pScmdline, int iCmdshow)
{
    std::chrono::high_resolution_clock::time_point appStart = std::chrono::high_resolution_clock::now();

    if (!init())
        return 0;

    const size_t dispatchX = 1 + c_width / 32;
    const size_t dispatchY = 1 + c_height / 32;

    FillSceneData(EScene::SphereOnPlane_LowLight, g_d3d.Context());

    bool done = false;
    while (!done)
    {
        // Handle the windows messages.
        MSG msg;
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        // If windows signals to end the application then exit out.
        if (msg.message == WM_QUIT)
        {
            done = true;
        }
        else
        {
            // TODO: put in separate file
            // Setup low-level inputs (e.g. on Win32, GetKeyboardState(), or write to those fields from your Windows message loop handlers, etc.)
            ImGuiIO& io = ImGui::GetIO();
            io.DeltaTime = 1.0f / 60.0f;
            // TODO: update input!
            //io.MousePos = mouse_pos;
            //io.MouseDown[0] = mouse_button_0;
            //io.MouseDown[1] = mouse_button_1;

            // Call NewFrame(), after this point you can use ImGui::* functions anytime
            ImGui::NewFrame();

            // TODO: temp!
            ImGui::ShowTestWindow();

            // update frame specific values
			bool firstSample = false;
            std::chrono::duration<float> appTimeSeconds = std::chrono::high_resolution_clock::now() - appStart;
            bool writeOK = ShaderData::ConstantBuffers::ConstantsPerFrame.Write(
                g_d3d.Context(),
                [&firstSample, &appTimeSeconds] (ShaderTypes::ConstantBuffers::ConstantsPerFrame& data)
                {
                    data.frameRnd_appTime_zw[0] = RandomFloat(0.0f, 1.0f);
                    data.frameRnd_appTime_zw[1] = appTimeSeconds.count();

                    data.sampleCount_yzw[0]++;

					firstSample = (data.sampleCount_yzw[0] == 1);
                }
            );
            if (!writeOK)
                done = true;

			// if this is sample 0, we need to run the code that generates the first intersection that is re-used by the path tracing and the shader that shows the path tracing results
			if (firstSample)
			{
                FillShaderParams<EShaderType::compute>(g_d3d.Context(), ShaderData::Shaders::pathTraceFirstHit.GetReflector());
                ShaderData::Shaders::pathTraceFirstHit.Dispatch(g_d3d.Context(), dispatchX, dispatchY, 1);
                UnbindShaderTextures<EShaderType::compute>(g_d3d.Context(), ShaderData::Shaders::pathTraceFirstHit.GetReflector());
			}

            // path tracing compute shader
            FillShaderParams<EShaderType::compute>(g_d3d.Context(), ShaderData::Shaders::pathTrace.GetReflector());
            ShaderData::Shaders::pathTrace.Dispatch(g_d3d.Context(), dispatchX, dispatchY, 1);
            UnbindShaderTextures<EShaderType::compute>(g_d3d.Context(), ShaderData::Shaders::pathTrace.GetReflector());

            // vs/ps to show the results of the path tracing
            CShader& shader = SelectShaderShowPathTrace();
            FillShaderParams<EShaderType::vertex>(g_d3d.Context(), shader.GetVSReflector());
            FillShaderParams<EShaderType::pixel>(g_d3d.Context(), shader.GetPSReflector());
            g_fullScreenMesh.Render(g_d3d.Context());
            shader.Draw(g_d3d.Context(), g_fullScreenMesh.GetIndexCount());
            UnbindShaderTextures<EShaderType::vertex>(g_d3d.Context(), shader.GetVSReflector());
            UnbindShaderTextures<EShaderType::pixel>(g_d3d.Context(), shader.GetPSReflector());

            // TODO: put imgui in it's own thing
            ImGui::Render();

            g_d3d.Present();
        }
    }

    return 0;
}